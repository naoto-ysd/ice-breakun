---
alwaysApply: true
---

# Ice Breakun ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£é–‹ç™ºã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## ğŸ¯ æ¦‚è¦
Ice Breakunãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£æ§‹ç¯‰ãƒ»é‹ç”¨ã«ãŠã‘ã‚‹ãƒ«ãƒ¼ãƒ«ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã§ã™ã€‚

## ğŸ—ï¸ ã‚¤ãƒ³ãƒ•ãƒ©æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- **ã‚³ãƒ³ãƒ†ãƒŠåŒ–**: Docker, Docker Compose
- **ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: AWS ECS (Fargate)
- **Infrastructure as Code**: Terraform
- **CI/CD**: GitHub Actions
- **ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼**: AWS
- **ãƒ¬ã‚¸ã‚¹ãƒˆãƒª**: Amazon ECR

## ğŸ³ Dockeræ§‹æˆ

### ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ
```
â”œâ”€â”€ Dockerfile              # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æœ¬ç•ªç”¨
â”œâ”€â”€ Dockerfile.prod         # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æœ¬ç•ªç”¨ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
â”œâ”€â”€ Dockerfile.backend      # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºç”¨
â”œâ”€â”€ Dockerfile.backend.prod # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰æœ¬ç•ªç”¨
â””â”€â”€ docker-compose.yml     # ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒ
```

### é–‹ç™ºç’°å¢ƒï¼ˆdocker-compose.ymlï¼‰
```yaml
# æ¨å¥¨æ§‹æˆä¾‹
version: '3.8'
services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - backend

  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:./data/ice_breakun.db
    volumes:
      - .:/app
      - /app/node_modules
      - ./data:/app/data
```

### ãƒãƒ«ãƒã‚¹ãƒ†ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰åŸå‰‡
```dockerfile
# æœ¬ç•ªç”¨Dockerfileä¾‹
FROM node:18-alpine as base
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine as production
WORKDIR /app
COPY --from=base /app/node_modules ./node_modules
COPY --from=build /app/.output ./.output
COPY --from=build /app/package.json ./

EXPOSE 3000
CMD ["node", ".output/server/index.mjs"]
```

### Dockeræœ€é©åŒ–ãƒ«ãƒ¼ãƒ«
1. **ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚µã‚¤ã‚ºæœ€é©åŒ–**
   - Alpine Linuxãƒ™ãƒ¼ã‚¹ã‚¤ãƒ¡ãƒ¼ã‚¸ã®ä½¿ç”¨
   - ä¸è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã¯`.dockerignore`ã§é™¤å¤–
   - ãƒãƒ«ãƒã‚¹ãƒ†ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰ã®æ´»ç”¨

2. **ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ€é©åŒ–**
   - package.jsonã‚’å…ˆã«ã‚³ãƒ”ãƒ¼ã—ã¦npm installã‚’å®Ÿè¡Œ
   - å¤‰æ›´é »åº¦ã®ä½ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…ˆã«ã‚³ãƒ”ãƒ¼

3. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**
   - érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã®å®Ÿè¡Œ
   - å¿…è¦æœ€å°é™ã®æ¨©é™è¨­å®š
   - æ©Ÿå¯†æƒ…å ±ã¯ãƒ“ãƒ«ãƒ‰æ™‚ã«åŸ‹ã‚è¾¼ã¾ãªã„

## â˜ï¸ AWS ECSæ§‹æˆ

### Terraformè¨­å®šï¼ˆecs.tfï¼‰
```hcl
# ECSã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼
resource "aws_ecs_cluster" "ice_breakun" {
  name = "ice-breakun-cluster"
  
  setting {
    name  = "containerInsights"
    value = "enabled"
  }
  
  tags = {
    Environment = var.environment
    Project     = "ice-breakun"
  }
}

# ECSã‚µãƒ¼ãƒ“ã‚¹
resource "aws_ecs_service" "frontend" {
  name            = "ice-breakun-frontend"
  cluster         = aws_ecs_cluster.ice_breakun.id
  task_definition = aws_ecs_task_definition.frontend.arn
  desired_count   = var.frontend_desired_count
  launch_type     = "FARGATE"
  
  network_configuration {
    subnets          = var.private_subnet_ids
    security_groups  = [aws_security_group.ecs.id]
    assign_public_ip = false
  }
  
  load_balancer {
    target_group_arn = aws_lb_target_group.frontend.arn
    container_name   = "frontend"
    container_port   = 3000
  }
}

# ã‚¿ã‚¹ã‚¯å®šç¾©
resource "aws_ecs_task_definition" "frontend" {
  family                   = "ice-breakun-frontend"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.frontend_cpu
  memory                   = var.frontend_memory
  execution_role_arn       = aws_iam_role.ecs_execution.arn
  task_role_arn           = aws_iam_role.ecs_task.arn
  
  container_definitions = jsonencode([
    {
      name  = "frontend"
      image = "${var.ecr_repository_url}:${var.image_tag}"
      portMappings = [
        {
          containerPort = 3000
          protocol      = "tcp"
        }
      ]
      environment = [
        {
          name  = "NODE_ENV"
          value = var.environment
        }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.ecs.name
          awslogs-region        = var.aws_region
          awslogs-stream-prefix = "frontend"
        }
      }
      healthCheck = {
        command     = ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"]
        interval    = 30
        timeout     = 5
        retries     = 3
        startPeriod = 60
      }
    }
  ])
}
```

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®š
```hcl
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—
resource "aws_security_group" "ecs" {
  name_prefix = "ice-breakun-ecs-"
  vpc_id      = var.vpc_id
  
  ingress {
    from_port       = 3000
    to_port         = 3000
    protocol        = "tcp"
    security_groups = [aws_security_group.alb.id]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  tags = {
    Name = "ice-breakun-ecs-sg"
  }
}

# Application Load Balancer
resource "aws_lb" "main" {
  name               = "ice-breakun-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = var.public_subnet_ids
  
  enable_deletion_protection = var.enable_deletion_protection
  
  tags = {
    Environment = var.environment
  }
}
```

### ç›£è¦–ãƒ»ãƒ­ã‚°è¨­å®š
```hcl
# CloudWatch Log Group
resource "aws_cloudwatch_log_group" "ecs" {
  name              = "/ecs/ice-breakun"
  retention_in_days = var.log_retention_days
  
  tags = {
    Environment = var.environment
  }
}

# CloudWatch Alarms
resource "aws_cloudwatch_metric_alarm" "cpu_high" {
  alarm_name          = "ice-breakun-cpu-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/ECS"
  period              = "300"
  statistic           = "Average"
  threshold           = "80"
  alarm_description   = "This metric monitors ecs cpu utilization"
  alarm_actions       = [aws_sns_topic.alerts.arn]
  
  dimensions = {
    ServiceName = aws_ecs_service.frontend.name
    ClusterName = aws_ecs_cluster.ice_breakun.name
  }
}
```

## ğŸš€ CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

### GitHub Actionsè¨­å®š
```yaml
# .github/workflows/deploy-to-ecr.yml
name: Deploy to ECR and ECS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: ap-northeast-1
  ECR_REPOSITORY: ice-breakun

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Run linting
        run: npm run lint
      
      - name: Run type checking
        run: npm run type-check

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build, tag, and push frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f Dockerfile.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:frontend-$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:frontend-$IMAGE_TAG
      
      - name: Build, tag, and push backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f Dockerfile.backend.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:backend-$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:backend-$IMAGE_TAG
      
      - name: Deploy to ECS
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          aws ecs update-service \
            --cluster ice-breakun-cluster \
            --service ice-breakun-frontend \
            --force-new-deployment
```

### ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥
1. **Blue/Green ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ**
   - ECSã‚µãƒ¼ãƒ“ã‚¹ã®æ®µéšçš„æ›´æ–°
   - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã«ã‚ˆã‚‹è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯

2. **ã‚¼ãƒ­ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ ãƒ‡ãƒ—ãƒ­ã‚¤**
   - ALBã«ã‚ˆã‚‹ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯åˆ¶å¾¡
   - ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³

3. **ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥**
   - ä»¥å‰ã®ã‚¿ã‚¹ã‚¯å®šç¾©ã¸ã®å³åº§ã®å¾©å…ƒ
   - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®è€ƒæ…®

## ğŸ”§ ç’°å¢ƒç®¡ç†

### ç’°å¢ƒåˆ†é›¢
```hcl
# ç’°å¢ƒåˆ¥å¤‰æ•°è¨­å®š
variable "environment" {
  description = "Environment name"
  type        = string
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

variable "frontend_desired_count" {
  description = "Desired number of frontend tasks"
  type        = number
  default = {
    dev     = 1
    staging = 1
    prod    = 2
  }
}

variable "frontend_cpu" {
  description = "CPU units for frontend tasks"
  type        = number
  default = {
    dev     = 256
    staging = 512
    prod    = 1024
  }
}
```

### ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆç®¡ç†
```hcl
# AWS Systems Manager Parameter Store
resource "aws_ssm_parameter" "database_url" {
  name  = "/ice-breakun/${var.environment}/database-url"
  type  = "SecureString"
  value = var.database_url
  
  tags = {
    Environment = var.environment
  }
}

# ECSã‚¿ã‚¹ã‚¯å®šç¾©ã§ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆå‚ç…§
container_definitions = jsonencode([
  {
    name = "backend"
    secrets = [
      {
        name      = "DATABASE_URL"
        valueFrom = aws_ssm_parameter.database_url.arn
      }
    ]
  }
])
```

## ğŸ“Š ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆ

### CloudWatch ãƒ¡ãƒˆãƒªã‚¯ã‚¹
```hcl
# ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹
resource "aws_cloudwatch_metric_alarm" "response_time" {
  alarm_name          = "ice-breakun-response-time"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "TargetResponseTime"
  namespace           = "AWS/ApplicationELB"
  period              = "300"
  statistic           = "Average"
  threshold           = "5"
  alarm_description   = "Response time is too high"
  
  dimensions = {
    LoadBalancer = aws_lb.main.arn_suffix
  }
}

# ã‚¨ãƒ©ãƒ¼ç‡ç›£è¦–
resource "aws_cloudwatch_metric_alarm" "error_rate" {
  alarm_name          = "ice-breakun-error-rate"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "3"
  metric_name         = "HTTPCode_Target_5XX_Count"
  namespace           = "AWS/ApplicationELB"
  period              = "300"
  statistic           = "Sum"
  threshold           = "10"
  alarm_description   = "5xx error rate is too high"
}
```

### ãƒ­ã‚°ç®¡ç†
```json
{
  "logConfiguration": {
    "logDriver": "awslogs",
    "options": {
      "awslogs-group": "/ecs/ice-breakun",
      "awslogs-region": "ap-northeast-1",
      "awslogs-stream-prefix": "ecs",
      "awslogs-datetime-format": "%Y-%m-%d %H:%M:%S"
    }
  }
}
```

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### IAMè¨­å®š
```hcl
# ECSå®Ÿè¡Œãƒ­ãƒ¼ãƒ«
resource "aws_iam_role" "ecs_execution" {
  name = "ice-breakun-ecs-execution-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "ecs_execution" {
  role       = aws_iam_role.ecs_execution.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}

# ECSã‚¿ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
resource "aws_iam_role" "ecs_task" {
  name = "ice-breakun-ecs-task-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      }
    ]
  })
}
```

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
1. **ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚µãƒ–ãƒãƒƒãƒˆ**
   - ECSã‚¿ã‚¹ã‚¯ã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚µãƒ–ãƒãƒƒãƒˆã§å®Ÿè¡Œ
   - NATã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤çµŒç”±ã§ã®ã‚¢ã‚¦ãƒˆãƒã‚¦ãƒ³ãƒ‰é€šä¿¡

2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—**
   - æœ€å°æ¨©é™ã®åŸå‰‡
   - ãƒãƒ¼ãƒˆ3000ã®ã¿ALBã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯

3. **WAFè¨­å®š**
   - SQL ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
   - XSSæ”»æ’ƒå¯¾ç­–
   - DDoSæ”»æ’ƒå¯¾ç­–

## ğŸƒâ€â™‚ï¸ é‹ç”¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæ‰‹é †
1. **äº‹å‰ãƒã‚§ãƒƒã‚¯**
   ```bash
   # Terraformãƒ—ãƒ©ãƒ³ã®ç¢ºèª
   terraform plan -var-file="environments/prod.tfvars"
   
   # Docker ã‚¤ãƒ¡ãƒ¼ã‚¸ã®ãƒ“ãƒ«ãƒ‰ãƒ†ã‚¹ãƒˆ
   docker build -f Dockerfile.prod .
   ```

2. **æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤**
   ```bash
   # ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆ
   terraform apply -var-file="environments/staging.tfvars"
   
   # æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤
   terraform apply -var-file="environments/prod.tfvars"
   ```

3. **ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯**
   ```bash
   # ECSã‚µãƒ¼ãƒ“ã‚¹ã®çŠ¶æ…‹ç¢ºèª
   aws ecs describe-services --cluster ice-breakun-cluster --services ice-breakun-frontend
   
   # ALBã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆçŠ¶æ…‹ç¢ºèª
   aws elbv2 describe-target-health --target-group-arn <TARGET_GROUP_ARN>
   ```

### ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æˆ¦ç•¥
```hcl
# Auto Scalingè¨­å®š
resource "aws_appautoscaling_target" "ecs_target" {
  max_capacity       = var.max_capacity
  min_capacity       = var.min_capacity
  resource_id        = "service/${aws_ecs_cluster.ice_breakun.name}/${aws_ecs_service.frontend.name}"
  scalable_dimension = "ecs:service:DesiredCount"
  service_namespace  = "ecs"
}

resource "aws_appautoscaling_policy" "cpu_policy" {
  name               = "ice-breakun-cpu-scaling"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.ecs_target.resource_id
  scalable_dimension = aws_appautoscaling_target.ecs_target.scalable_dimension
  service_namespace  = aws_appautoscaling_target.ecs_target.service_namespace
  
  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
    }
    target_value = 70.0
  }
}
```

### ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ç½å®³å¾©æ—§
1. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—**
   - è‡ªå‹•ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼ˆRDSä½¿ç”¨æ™‚ï¼‰
   - å®šæœŸçš„ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

2. **è¨­å®šã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†**
   - Terraformã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªãƒ¢ãƒ¼ãƒˆç®¡ç†
   - è¨­å®šå¤‰æ›´ã®å±¥æ­´ç®¡ç†

3. **ç½å®³å¾©æ—§è¨ˆç”»**
   - åˆ¥ãƒªãƒ¼ã‚¸ãƒ§ãƒ³ã§ã®å¾©æ—§æ‰‹é †
   - RPO/RTOã®è¨­å®š

## ğŸš¨ é‡è¦ãªæ³¨æ„äº‹é …

1. **ã‚³ã‚¹ãƒˆæœ€é©åŒ–**
   - é©åˆ‡ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚µã‚¤ã‚ºã®é¸æŠ
   - ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
   - ä¸è¦ãªãƒªã‚½ãƒ¼ã‚¹ã®å®šæœŸçš„ãªå‰Šé™¤

2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**
   - å®šæœŸçš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ‘ãƒƒãƒé©ç”¨
   - IAMãƒ­ãƒ¼ãƒ«ã®æœ€å°æ¨©é™è¨­å®š
   - ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆæƒ…å ±ã®é©åˆ‡ãªç®¡ç†

3. **ç›£è¦–**
   - é‡è¦ãªãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ç¶™ç¶šçš„ãªç›£è¦–
   - ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®šã®æœ€é©åŒ–
   - ãƒ­ã‚°ã®å®šæœŸçš„ãªåˆ†æ

4. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**
   - ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡ã®å®šæœŸçš„ãªè¦‹ç›´ã—
   - ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã®ç‰¹å®šã¨æ”¹å–„
   - ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®æœ€é©åŒ–

## ğŸ“š å‚è€ƒè³‡æ–™
- [AWS ECS Documentation](https://docs.aws.amazon.com/ecs/)
- [Terraform AWS Provider](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [AWS Well-Architected Framework](https://docs.aws.amazon.com/wellarchitected/) # Ice Breakun ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£é–‹ç™ºã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## ğŸ¯ æ¦‚è¦
Ice Breakunãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£æ§‹ç¯‰ãƒ»é‹ç”¨ã«ãŠã‘ã‚‹ãƒ«ãƒ¼ãƒ«ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã§ã™ã€‚

## ğŸ—ï¸ ã‚¤ãƒ³ãƒ•ãƒ©æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- **ã‚³ãƒ³ãƒ†ãƒŠåŒ–**: Docker, Docker Compose
- **ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: AWS ECS (Fargate)
- **Infrastructure as Code**: Terraform
- **CI/CD**: GitHub Actions
- **ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼**: AWS
- **ãƒ¬ã‚¸ã‚¹ãƒˆãƒª**: Amazon ECR

## ğŸ³ Dockeræ§‹æˆ

### ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ
```
â”œâ”€â”€ Dockerfile              # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æœ¬ç•ªç”¨
â”œâ”€â”€ Dockerfile.prod         # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æœ¬ç•ªç”¨ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
â”œâ”€â”€ Dockerfile.backend      # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºç”¨
â”œâ”€â”€ Dockerfile.backend.prod # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰æœ¬ç•ªç”¨
â””â”€â”€ docker-compose.yml     # ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒ
```

### é–‹ç™ºç’°å¢ƒï¼ˆdocker-compose.ymlï¼‰
```yaml
# æ¨å¥¨æ§‹æˆä¾‹
version: '3.8'
services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - backend

  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:./data/ice_breakun.db
    volumes:
      - .:/app
      - /app/node_modules
      - ./data:/app/data
```

### ãƒãƒ«ãƒã‚¹ãƒ†ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰åŸå‰‡
```dockerfile
# æœ¬ç•ªç”¨Dockerfileä¾‹
FROM node:18-alpine as base
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine as production
WORKDIR /app
COPY --from=base /app/node_modules ./node_modules
COPY --from=build /app/.output ./.output
COPY --from=build /app/package.json ./

EXPOSE 3000
CMD ["node", ".output/server/index.mjs"]
```

### Dockeræœ€é©åŒ–ãƒ«ãƒ¼ãƒ«
1. **ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚µã‚¤ã‚ºæœ€é©åŒ–**
   - Alpine Linuxãƒ™ãƒ¼ã‚¹ã‚¤ãƒ¡ãƒ¼ã‚¸ã®ä½¿ç”¨
   - ä¸è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã¯`.dockerignore`ã§é™¤å¤–
   - ãƒãƒ«ãƒã‚¹ãƒ†ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰ã®æ´»ç”¨

2. **ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ€é©åŒ–**
   - package.jsonã‚’å…ˆã«ã‚³ãƒ”ãƒ¼ã—ã¦npm installã‚’å®Ÿè¡Œ
   - å¤‰æ›´é »åº¦ã®ä½ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…ˆã«ã‚³ãƒ”ãƒ¼

3. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**
   - érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã®å®Ÿè¡Œ
   - å¿…è¦æœ€å°é™ã®æ¨©é™è¨­å®š
   - æ©Ÿå¯†æƒ…å ±ã¯ãƒ“ãƒ«ãƒ‰æ™‚ã«åŸ‹ã‚è¾¼ã¾ãªã„

## â˜ï¸ AWS ECSæ§‹æˆ

### Terraformè¨­å®šï¼ˆecs.tfï¼‰
```hcl
# ECSã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼
resource "aws_ecs_cluster" "ice_breakun" {
  name = "ice-breakun-cluster"
  
  setting {
    name  = "containerInsights"
    value = "enabled"
  }
  
  tags = {
    Environment = var.environment
    Project     = "ice-breakun"
  }
}

# ECSã‚µãƒ¼ãƒ“ã‚¹
resource "aws_ecs_service" "frontend" {
  name            = "ice-breakun-frontend"
  cluster         = aws_ecs_cluster.ice_breakun.id
  task_definition = aws_ecs_task_definition.frontend.arn
  desired_count   = var.frontend_desired_count
  launch_type     = "FARGATE"
  
  network_configuration {
    subnets          = var.private_subnet_ids
    security_groups  = [aws_security_group.ecs.id]
    assign_public_ip = false
  }
  
  load_balancer {
    target_group_arn = aws_lb_target_group.frontend.arn
    container_name   = "frontend"
    container_port   = 3000
  }
}

# ã‚¿ã‚¹ã‚¯å®šç¾©
resource "aws_ecs_task_definition" "frontend" {
  family                   = "ice-breakun-frontend"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.frontend_cpu
  memory                   = var.frontend_memory
  execution_role_arn       = aws_iam_role.ecs_execution.arn
  task_role_arn           = aws_iam_role.ecs_task.arn
  
  container_definitions = jsonencode([
    {
      name  = "frontend"
      image = "${var.ecr_repository_url}:${var.image_tag}"
      portMappings = [
        {
          containerPort = 3000
          protocol      = "tcp"
        }
      ]
      environment = [
        {
          name  = "NODE_ENV"
          value = var.environment
        }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.ecs.name
          awslogs-region        = var.aws_region
          awslogs-stream-prefix = "frontend"
        }
      }
      healthCheck = {
        command     = ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"]
        interval    = 30
        timeout     = 5
        retries     = 3
        startPeriod = 60
      }
    }
  ])
}
```

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®š
```hcl
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—
resource "aws_security_group" "ecs" {
  name_prefix = "ice-breakun-ecs-"
  vpc_id      = var.vpc_id
  
  ingress {
    from_port       = 3000
    to_port         = 3000
    protocol        = "tcp"
    security_groups = [aws_security_group.alb.id]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  tags = {
    Name = "ice-breakun-ecs-sg"
  }
}

# Application Load Balancer
resource "aws_lb" "main" {
  name               = "ice-breakun-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = var.public_subnet_ids
  
  enable_deletion_protection = var.enable_deletion_protection
  
  tags = {
    Environment = var.environment
  }
}
```

### ç›£è¦–ãƒ»ãƒ­ã‚°è¨­å®š
```hcl
# CloudWatch Log Group
resource "aws_cloudwatch_log_group" "ecs" {
  name              = "/ecs/ice-breakun"
  retention_in_days = var.log_retention_days
  
  tags = {
    Environment = var.environment
  }
}

# CloudWatch Alarms
resource "aws_cloudwatch_metric_alarm" "cpu_high" {
  alarm_name          = "ice-breakun-cpu-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/ECS"
  period              = "300"
  statistic           = "Average"
  threshold           = "80"
  alarm_description   = "This metric monitors ecs cpu utilization"
  alarm_actions       = [aws_sns_topic.alerts.arn]
  
  dimensions = {
    ServiceName = aws_ecs_service.frontend.name
    ClusterName = aws_ecs_cluster.ice_breakun.name
  }
}
```

## ğŸš€ CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

### GitHub Actionsè¨­å®š
```yaml
# .github/workflows/deploy-to-ecr.yml
name: Deploy to ECR and ECS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: ap-northeast-1
  ECR_REPOSITORY: ice-breakun

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Run linting
        run: npm run lint
      
      - name: Run type checking
        run: npm run type-check

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build, tag, and push frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f Dockerfile.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:frontend-$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:frontend-$IMAGE_TAG
      
      - name: Build, tag, and push backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f Dockerfile.backend.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:backend-$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:backend-$IMAGE_TAG
      
      - name: Deploy to ECS
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          aws ecs update-service \
            --cluster ice-breakun-cluster \
            --service ice-breakun-frontend \
            --force-new-deployment
```

### ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥
1. **Blue/Green ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ**
   - ECSã‚µãƒ¼ãƒ“ã‚¹ã®æ®µéšçš„æ›´æ–°
   - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã«ã‚ˆã‚‹è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯

2. **ã‚¼ãƒ­ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ ãƒ‡ãƒ—ãƒ­ã‚¤**
   - ALBã«ã‚ˆã‚‹ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯åˆ¶å¾¡
   - ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³

3. **ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥**
   - ä»¥å‰ã®ã‚¿ã‚¹ã‚¯å®šç¾©ã¸ã®å³åº§ã®å¾©å…ƒ
   - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®è€ƒæ…®

## ğŸ”§ ç’°å¢ƒç®¡ç†

### ç’°å¢ƒåˆ†é›¢
```hcl
# ç’°å¢ƒåˆ¥å¤‰æ•°è¨­å®š
variable "environment" {
  description = "Environment name"
  type        = string
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

variable "frontend_desired_count" {
  description = "Desired number of frontend tasks"
  type        = number
  default = {
    dev     = 1
    staging = 1
    prod    = 2
  }
}

variable "frontend_cpu" {
  description = "CPU units for frontend tasks"
  type        = number
  default = {
    dev     = 256
    staging = 512
    prod    = 1024
  }
}
```

### ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆç®¡ç†
```hcl
# AWS Systems Manager Parameter Store
resource "aws_ssm_parameter" "database_url" {
  name  = "/ice-breakun/${var.environment}/database-url"
  type  = "SecureString"
  value = var.database_url
  
  tags = {
    Environment = var.environment
  }
}

# ECSã‚¿ã‚¹ã‚¯å®šç¾©ã§ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆå‚ç…§
container_definitions = jsonencode([
  {
    name = "backend"
    secrets = [
      {
        name      = "DATABASE_URL"
        valueFrom = aws_ssm_parameter.database_url.arn
      }
    ]
  }
])
```

## ğŸ“Š ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆ

### CloudWatch ãƒ¡ãƒˆãƒªã‚¯ã‚¹
```hcl
# ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹
resource "aws_cloudwatch_metric_alarm" "response_time" {
  alarm_name          = "ice-breakun-response-time"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "TargetResponseTime"
  namespace           = "AWS/ApplicationELB"
  period              = "300"
  statistic           = "Average"
  threshold           = "5"
  alarm_description   = "Response time is too high"
  
  dimensions = {
    LoadBalancer = aws_lb.main.arn_suffix
  }
}

# ã‚¨ãƒ©ãƒ¼ç‡ç›£è¦–
resource "aws_cloudwatch_metric_alarm" "error_rate" {
  alarm_name          = "ice-breakun-error-rate"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "3"
  metric_name         = "HTTPCode_Target_5XX_Count"
  namespace           = "AWS/ApplicationELB"
  period              = "300"
  statistic           = "Sum"
  threshold           = "10"
  alarm_description   = "5xx error rate is too high"
}
```

### ãƒ­ã‚°ç®¡ç†
```json
{
  "logConfiguration": {
    "logDriver": "awslogs",
    "options": {
      "awslogs-group": "/ecs/ice-breakun",
      "awslogs-region": "ap-northeast-1",
      "awslogs-stream-prefix": "ecs",
      "awslogs-datetime-format": "%Y-%m-%d %H:%M:%S"
    }
  }
}
```

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### IAMè¨­å®š
```hcl
# ECSå®Ÿè¡Œãƒ­ãƒ¼ãƒ«
resource "aws_iam_role" "ecs_execution" {
  name = "ice-breakun-ecs-execution-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "ecs_execution" {
  role       = aws_iam_role.ecs_execution.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}

# ECSã‚¿ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
resource "aws_iam_role" "ecs_task" {
  name = "ice-breakun-ecs-task-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      }
    ]
  })
}
```

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
1. **ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚µãƒ–ãƒãƒƒãƒˆ**
   - ECSã‚¿ã‚¹ã‚¯ã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚µãƒ–ãƒãƒƒãƒˆã§å®Ÿè¡Œ
   - NATã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤çµŒç”±ã§ã®ã‚¢ã‚¦ãƒˆãƒã‚¦ãƒ³ãƒ‰é€šä¿¡

2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—**
   - æœ€å°æ¨©é™ã®åŸå‰‡
   - ãƒãƒ¼ãƒˆ3000ã®ã¿ALBã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯

3. **WAFè¨­å®š**
   - SQL ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
   - XSSæ”»æ’ƒå¯¾ç­–
   - DDoSæ”»æ’ƒå¯¾ç­–

## ğŸƒâ€â™‚ï¸ é‹ç”¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæ‰‹é †
1. **äº‹å‰ãƒã‚§ãƒƒã‚¯**
   ```bash
   # Terraformãƒ—ãƒ©ãƒ³ã®ç¢ºèª
   terraform plan -var-file="environments/prod.tfvars"
   
   # Docker ã‚¤ãƒ¡ãƒ¼ã‚¸ã®ãƒ“ãƒ«ãƒ‰ãƒ†ã‚¹ãƒˆ
   docker build -f Dockerfile.prod .
   ```

2. **æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤**
   ```bash
   # ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆ
   terraform apply -var-file="environments/staging.tfvars"
   
   # æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤
   terraform apply -var-file="environments/prod.tfvars"
   ```

3. **ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯**
   ```bash
   # ECSã‚µãƒ¼ãƒ“ã‚¹ã®çŠ¶æ…‹ç¢ºèª
   aws ecs describe-services --cluster ice-breakun-cluster --services ice-breakun-frontend
   
   # ALBã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆçŠ¶æ…‹ç¢ºèª
   aws elbv2 describe-target-health --target-group-arn <TARGET_GROUP_ARN>
   ```

### ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æˆ¦ç•¥
```hcl
# Auto Scalingè¨­å®š
resource "aws_appautoscaling_target" "ecs_target" {
  max_capacity       = var.max_capacity
  min_capacity       = var.min_capacity
  resource_id        = "service/${aws_ecs_cluster.ice_breakun.name}/${aws_ecs_service.frontend.name}"
  scalable_dimension = "ecs:service:DesiredCount"
  service_namespace  = "ecs"
}

resource "aws_appautoscaling_policy" "cpu_policy" {
  name               = "ice-breakun-cpu-scaling"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.ecs_target.resource_id
  scalable_dimension = aws_appautoscaling_target.ecs_target.scalable_dimension
  service_namespace  = aws_appautoscaling_target.ecs_target.service_namespace
  
  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
    }
    target_value = 70.0
  }
}
```

### ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ç½å®³å¾©æ—§
1. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—**
   - è‡ªå‹•ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼ˆRDSä½¿ç”¨æ™‚ï¼‰
   - å®šæœŸçš„ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

2. **è¨­å®šã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†**
   - Terraformã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªãƒ¢ãƒ¼ãƒˆç®¡ç†
   - è¨­å®šå¤‰æ›´ã®å±¥æ­´ç®¡ç†

3. **ç½å®³å¾©æ—§è¨ˆç”»**
   - åˆ¥ãƒªãƒ¼ã‚¸ãƒ§ãƒ³ã§ã®å¾©æ—§æ‰‹é †
   - RPO/RTOã®è¨­å®š

## ğŸš¨ é‡è¦ãªæ³¨æ„äº‹é …

1. **ã‚³ã‚¹ãƒˆæœ€é©åŒ–**
   - é©åˆ‡ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚µã‚¤ã‚ºã®é¸æŠ
   - ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
   - ä¸è¦ãªãƒªã‚½ãƒ¼ã‚¹ã®å®šæœŸçš„ãªå‰Šé™¤

2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**
   - å®šæœŸçš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ‘ãƒƒãƒé©ç”¨
   - IAMãƒ­ãƒ¼ãƒ«ã®æœ€å°æ¨©é™è¨­å®š
   - ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆæƒ…å ±ã®é©åˆ‡ãªç®¡ç†

3. **ç›£è¦–**
   - é‡è¦ãªãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ç¶™ç¶šçš„ãªç›£è¦–
   - ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®šã®æœ€é©åŒ–
   - ãƒ­ã‚°ã®å®šæœŸçš„ãªåˆ†æ

4. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**
   - ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡ã®å®šæœŸçš„ãªè¦‹ç›´ã—
   - ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã®ç‰¹å®šã¨æ”¹å–„
   - ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®æœ€é©åŒ–

## ğŸ“š å‚è€ƒè³‡æ–™
- [AWS ECS Documentation](https://docs.aws.amazon.com/ecs/)
- [Terraform AWS Provider](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [AWS Well-Architected Framework](https://docs.aws.amazon.com/wellarchitected/) 